// В качестве задачи для работы с массивами, я выбрал упорядочивание данных
// внутри массива. Существуют разные алгоритмы, которые вы, скорее всего, будете писать в
// дальнейшем. Остановимся на одном из самых простых. Это так называемый алгоритм
// сортировки методом выбора, ещё его называют алгоритм сортировки методом минимакса или
// иногда просто называют методом максимального, или выбора максимального или выбора
// минимального и так далее. Узнаем, в чём особенность (суть) этого алгоритма. Есть какая-то
// последовательность чисел. Наша задача — выбрать самый первый элемент и в оставшейся
// части, с учётом нашей текущей позиции определить минимальный. После того как он найден,
// нужно поменять выделенный (рабочий элемент), на который сейчас указывает стрелочка, это
// 6, с единицей, являющейся для нас минимальной, в общем, выделенном куске.
// Было: 6 8 3 2 1 4 5 7
// Стало: 1 8 3 2 6 4 5 7
// Поменяли. Дальше у нас следующий шаг, который будет выбирать очередной рабочий элемент
// для нас. Это теперь 8. Мы явно указываем то, что 1 уже отсортированы к ней больше касаться
// 11
// не нужно. Дальше наша задача во всём неотсортированном кусочке выбрать снова
// минимальный. Поменять его местами с рабочим.
// Было: 1 8 3 2 6 4 5 7
// Стало: 1 2 3 8 6 4 5 7
// В таком случае получается подмассив или кусок массива из первых двух элементов
// отсортирован. Дальше переходим к следующему элементу, снова находим минимальный, и
// здесь получается так, что нам ничего ни с чем менять не нужно, то есть, он остаётся на своей
// позиции. На следующем этапе переходим к следующему рабочему элементу. Снова находим
// минимальный, снова меняем их местами, таким образом, мы продолжаем до того момента,
// пока весь массив не будет отсортирован.
// Результат: 1 2 3 4 5 6 7 8

// На самом деле мы сами указали достаточно много действий, но в то же время они могут быть
// выражены тремя пунктами.
// 1. Найти позицию минимального элемента в неотсортированной части массива.
// 2. Произвести обмен этого значения со значением первой неотсортированной позиции.
// 3. Повторять пока есть неотсортированные элементы.

int[] arr = { 1, 5, 4, 3, 2, 6, 7, 1, 1 }; //заведём массив, который будем сортировать

void PrintArray(int[] array) // Для этого алгоритма абсолютно не принципиально, если внутри массива будут повторяющиеся
// элементы. На следующем этапе решим небольшую подзадачу, отвечающую за вывод данных
// массива на экран. Напишем отдельный метод. Причём сделаем это несколькими способами.
// Первый это метод void, назовём его PrintArray. В качестве аргумента будет приходить массив.
// Дальше. Получение, количество элементов (буду давать разные наименования, чтобы вы тоже потихонечку к этому привыкали) Length.
{
    int count = array.Length;
    for (int i = 0; i < count; i++) //Здесь цикл for, в котором мы пробегаем по всем элементам нашего массива. 
    {
        Console.Write($"{array[i]} "); //Показываем на экране. Можно это сделать так, чтобы вывод
                                       // осуществлялся в одну строку. Напишем действие array[i] и через пробел будем указывать.
    }
    Console.WriteLine(); // После того как вывод окончен, выведем на экран пустую строку Console.WriteLine. 
}
// Следующий этап. Нам нужно написать метод, который будет упорядочивать наш массив.
void SelectionSort(int[] array) // Назовём его selectionSort. В качестве аргумента точно таким же образом, как и в методе
                                // выше, будет приходить некий массив array. 
{
    for (int i = 0; i < array.Length - 1; i++) // Теперь, значит, нам нужно в первую очередь пробежаться по всем элементам нашего массива.
                                           //Чтобы не нарушать общность,
                                           // сделаем определение обращение к длине нашего массива через array.Length. Но здесь есть
                                           // отдельная особенность, о которой мы чуть-чуть позже поговорим.
    {
        int minPosition = i; //На следующем этапе мы определяем позицию, на которую смотрим. Назовём её minPosition.
                             //И запоминаем позицию рабочего элемента, для которого мы в дальнейшем будем производить какие-то действия
        for (int j = i + 1; j < array.Length; j++) //воспользуемся циклом внутри цикла Начальная позиция, от которой мы будем начинать эти
                                                   // действия, как вы помните, это кусочек массива, который был отсортирован, мы уже его не
                                                   // касаемся, а то, что нас отсортировано, начинается как раз с позиции i+1. И идём мы до
                                                   // последнего элемента array.Length.

        {
            if (array[j] < array[minPosition]) minPosition = j; //что мы делаем — это ищем минимальный элемент Чтобы это сделать,
                                                                // мы смотрим текущий, если он меньше того элемента, который мы предполагали на
                                                                // минимальной позиции minPosition, то нужно сохранить текущую позицию
                                                                // Этот блок кода ищет максимальный элемент и ниже производится swap
        }
        int temporary = array[i]; //нам потребуется поменять значение нашей минимальной позиции, с найденной нами позицией.
        array[i] = array[minPosition]; //Поэтому так и сделаем. Значит, int temporary = array. Наша рабочая оппозиция,
        array[minPosition] = temporary; // напоминаю, что она будет вычисляться индексом i
        //Соответственно, в i позицию, мы должны будем положить элемент, который будет найден в
        // процессе работы, этого пока не написанного кусочка кода. То есть, это простой обмен двух
        // переменных местами.
    }
}
PrintArray(arr); //PrintArray(arr), где arr это наименование нашего метода. Очистим консоль, запустим и посмотрим на результат.
SelectionSort(arr); // попробуем продублировать этот блок кода. И вызвать упорядочивание массива SelectionSort(arr)
PrintArray(arr);


// Дальше самый важный пункт заключается в том, что если мы начинаем позицию поиска
// максимального от индекса i+1, где i меняется до максимального значения позиции нашего
// массива, то в этом случае мы должны будем искусственно одну единицу отнять. Тогда
// получится, что ровно это i+1 даст общее количество элементов.for (int i = 0; i < array.Length - 1; i++)




